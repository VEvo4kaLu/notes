# Fetch with ties

Современный стандарт SQL (начиная с SQL:2008) ввел конструкцию **`FETCH FIRST ... WITH TIES`**. Это «синтаксический сахар», который позволяет решить твою задачу без подзапросов, CTE и оконных функций.

Вот как выглядит этот запрос:

```sql
SELECT 
    t.worker_title
FROM worker w
JOIN title t ON w.worker_id = t.worker_ref_id
ORDER BY w.salary DESC
FETCH FIRST 1 ROWS WITH TIES;

```

### Как это работает?

1. **`ORDER BY w.salary DESC`**: Мы сначала сортируем всех сотрудников от самой большой зарплаты к самой маленькой.
2. **`FETCH FIRST 1 ROWS`**: Мы говорим базе: «Дай мне только первую строку» (сотрудника с максимальной зарплатой).
3. **`WITH TIES`**: Это магическая часть. Она говорит: «Если у следующих строк значения в колонке сортировки (`salary`) такие же, как у первой, — **тоже включи их в результат**».

### Почему это круто?

* **Минимум кода:** Не нужно создавать временные таблицы (CTE) или вложенные селекты.
* **Декларативность:** Ты буквально описываешь результат: «Отсортируй и возьми лидеров».
* **Производительность:** Современные оптимизаторы (особенно в PostgreSQL, Oracle и SQL Server) очень эффективно обрабатывают `WITH TIES`, так как им не нужно высчитывать ранги для всей таблицы — они просто останавливаются, как только зарплата в отсортированном списке начинает снижаться.

---

### Сравнение синтаксиса

| Метод | Сложность | Читаемость | Поддержка |
| --- | --- | --- | --- |
| **Твой (CTE + DENSE_RANK)** | Средняя | Отличная | Почти все БД |
| **Modern (FETCH WITH TIES)** | Низкая | **Идеальная** | Postgres 13+, Oracle, SQL Server |

> **Важный нюанс:** Если ты используешь MySQL, там этот стандарт пока не поддерживается — там всё еще приходится использовать либо оконные функции, либо подзапросы. А вот в **PostgreSQL** (начиная с 13 версии) это самый элегантный способ.

# Windows function alias

Вот короткие заметки (cheat sheet) по SQL-оптимизациям, которые мы разобрали:

### 1. Убирай лишние сортировки (`ORDER BY`) в CTE

* **Проблема:** Ты сортировал данные внутри CTE с `GROUP BY`.
* **Почему это плохо:** Сортировка — одна из самых «дорогих» операций для базы данных (CPU + RAM). Порядок строк внутри CTE **не гарантирует** порядок в финальной выдаче.
* **Решение:** Используй `ORDER BY` только в самом финальном `SELECT` (или внутри оконных функций).

### 2. Сокращай цепочки CTE (Flattening)

* **Проблема:** Ты создал отдельный CTE `prev_revenues` только для того, чтобы добавить одну колонку через `LAG`.
* **Почему это плохо:** Лишние шаги заставляют планировщик запросов (query planner) работать сложнее, иногда материализуя временные таблицы в памяти или на диске.
* **Решение:** Выполняй оконные функции сразу в финальном `SELECT` или объединяй их с агрегацией, если диалект позволяет.

### 3. Защита от деления на ноль (`NULLIF`)

* **Проблема:** Формула `(a - b) / b` упадет с ошибкой, если `b = 0` (например, месяц без выручки).
* **Решение:** Используй конструкцию `NULLIF(знаменатель, 0)`.
* **Результат:** Вместо падения всего запроса ты получишь `NULL` в конкретной строке, что безопаснее для продакшена.

### 4. Целочисленное деление (Integer Division)

* **Важный нюанс:** Ты сделал правильно, умножив на `100.0`, но это стоит помнить.
* **Правило:** В SQL деление целого на целое (`5 / 2`) часто дает целое (`2`). Всегда приводи один из аргументов к `FLOAT` или `DECIMAL` перед делением.

### 5. Именованные окна (Named Windows) — *для чистоты кода*

* **Совет:** Если ты используешь одно и то же окно `OVER (ORDER BY date)` несколько раз (для `LAG`, `RANK` и т.д.), вынеси его в блок `WINDOW w AS (...)` в конце запроса (поддерживается в PostgreSQL и Spark SQL). Это делает код компактнее (DRY — Don't Repeat Yourself).

