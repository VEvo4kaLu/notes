# Fetch with ties

Современный стандарт SQL (начиная с SQL:2008) ввел конструкцию **`FETCH FIRST ... WITH TIES`**. Это «синтаксический сахар», который позволяет решить твою задачу без подзапросов, CTE и оконных функций.

Вот как выглядит этот запрос:

```sql
SELECT 
    t.worker_title
FROM worker w
JOIN title t ON w.worker_id = t.worker_ref_id
ORDER BY w.salary DESC
FETCH FIRST 1 ROWS WITH TIES;

```

### Как это работает?

1. **`ORDER BY w.salary DESC`**: Мы сначала сортируем всех сотрудников от самой большой зарплаты к самой маленькой.
2. **`FETCH FIRST 1 ROWS`**: Мы говорим базе: «Дай мне только первую строку» (сотрудника с максимальной зарплатой).
3. **`WITH TIES`**: Это магическая часть. Она говорит: «Если у следующих строк значения в колонке сортировки (`salary`) такие же, как у первой, — **тоже включи их в результат**».

### Почему это круто?

* **Минимум кода:** Не нужно создавать временные таблицы (CTE) или вложенные селекты.
* **Декларативность:** Ты буквально описываешь результат: «Отсортируй и возьми лидеров».
* **Производительность:** Современные оптимизаторы (особенно в PostgreSQL, Oracle и SQL Server) очень эффективно обрабатывают `WITH TIES`, так как им не нужно высчитывать ранги для всей таблицы — они просто останавливаются, как только зарплата в отсортированном списке начинает снижаться.

---

### Сравнение синтаксиса

| Метод | Сложность | Читаемость | Поддержка |
| --- | --- | --- | --- |
| **Твой (CTE + DENSE_RANK)** | Средняя | Отличная | Почти все БД |
| **Modern (FETCH WITH TIES)** | Низкая | **Идеальная** | Postgres 13+, Oracle, SQL Server |

> **Важный нюанс:** Если ты используешь MySQL, там этот стандарт пока не поддерживается — там всё еще приходится использовать либо оконные функции, либо подзапросы. А вот в **PostgreSQL** (начиная с 13 версии) это самый элегантный способ.

